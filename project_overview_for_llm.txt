Voxel Explorer Project Overview for LLMs (Last Updated: 2024-07-29 - AI Assisted Review)

This document provides a detailed breakdown of the Voxel Explorer game project, based on its codebase, technical specification, and current implementation status.

0. Vision & Scope
A hyper-performant, desktop-web voxel game with procedurally generated terrain. The authoritative server simulates physics (target 30 Hz), and the client targets 60 FPS. MVP focuses on exploration, mining, and building. Future scope includes multiplayer (up to 10 players), resources, and combat.

1. Core Technologies
   - Rendering: Three.js (WebGL2) using `vite` for bundling.
   - Physics: Server-side authoritative with Rapier3D (WASM). Greedy meshing for terrain colliders. Client-side movement prediction and reconciliation.
   - Networking: Raw WebSockets (Client: native `WebSocket`, Server: `'ws'` library). JSON for most messages. FlatBuffers for player state updates (integration of S0-1 milestone complete, broader use pending).
   - Language: TypeScript.
   - ECS: `'bitecs'` library for client-side entity and component management. Server-side ECS using `'bitecs'` for player entities.
   - World Generation: Server-side procedural generation. Client requests chunk data from server. Client-side `noiseWorker` as fallback. Client-side `mesherWorker` for visual meshes.

2. Project Structure (`src/`)

   - `main.tsx`: Main client-side entry point. Initializes Three.js scene, ECS world, systems, game loop, core managers (`ChunkManager`, `NetworkManager`), debug UI, and global event listeners.
   - `ecs/`: Entity Component System (client-side).
     - `world.ts`: Defines `bitecs` world factory and core `Transform` component.
     - `components/`: `CameraTarget.ts`, etc.
     - `systems/`: `transformSystem.ts`, `CameraSystem.ts`, `inputLookSystem.ts`, `PlayerMovementSystem.ts` (handles client-side movement logic, uses `NetworkManager` for server comms).
   - `world/`: Client-side voxel world logic.
     - `Chunk.ts`: Defines `CHUNK_SIZE`, `LODLevel`. Client-side `Chunk` class.
     - `noiseWorker.ts`: Fallback procedural terrain generation.
     - `NoiseManager.ts`: Manages `noiseWorker.ts`.
     - `mesherWorker.ts`: Web Worker for generating client-side visual chunk meshes (currently simple block-by-block, face culling; greedy meshing is a TODO for visuals).
     - `MesherManager.ts`: Manages `mesherWorker.ts`.
     - `ChunkManager.ts`: Orchestrates client-side chunk loading (requests from server), LOD switching, and visual meshing.
   - `net/`: Client-side networking.
     - `WebSocketClient.ts`: Manages WebSocket connection.
     - `types.ts`: Client-side network types.
     - `InputHandler.ts`: Role reduced, primarily for pointer lock state.
     - `NetworkManager.ts`: Coordinates client-side networking. Sends player inputs (FlatBuffers) and other commands (JSON). Handles server state updates (FlatBuffers), block updates (JSON), and errors. Manages client-side prediction and reconciliation.
     - `flat.ts`: Contains helper functions for encoding/decoding FlatBuffers messages (e.g., `ServerSnapshot`, `PlayerInput`).
   - `server/`: Server-side logic.
     - `matchServer.ts`: Main server application.
       - Initializes Rapier physics, server-side ECS.
       - Manages `MatchState` (players, chunks, physics world, `ChunkGenerationQueue`).
       - Handles client connections, player initialization (including physics body creation).
       - `handleMessage`: Processes client commands:
         - `PLAYER_INPUT` (FlatBuffer): Updates player's intended movement, yaw, flying state, jump state in Rapier physics world via `setLinvel`.
         - `MINE_BLOCK`/`PLACE_BLOCK` (JSON): Validates commands, updates server-side chunk data (`setBlock` via `voxelIO.ts`), immediately removes and then rebuilds greedy colliders for the affected chunk using `buildChunkColliders.ts`, and broadcasts `blockUpdate` (JSON RLE) to clients.
         - `chunkRequest` (JSON): Uses `getOrCreateChunk` (via `chunkGenerationQueue.ts`) to provide chunk data.
       - Game loop: Steps physics, processes pending collider tasks, handles player initialization, broadcasts player states (FlatBuffers), and performs chunk garbage collection.
     - `physics/`: Server-side physics logic.
       - `physics.ts`: Rapier3D initialization.
       - `buildChunkColliders.ts`: Implements greedy meshing for server-side terrain colliders. Contains `isBlockExposed` logic. Central to current physics debugging.
       - `removeChunkColliders.ts`: Removes colliders for a chunk, typically for GC.
       - `playerFactory.ts`: Creates Rapier physics bodies for players.
       - `movementConsts.ts`: Constants for player speed, acceleration etc.
     - `world/`: Server-side world data management.
       - `types.ts`: Server-side `MatchState`, `PlayerServer`, `Chunk` types. `Chunk.colliderHandles` stores Rapier collider handles for greedy meshes.
       - `genChunk.ts`: Generates chunk voxel data.
       - `voxelIO.ts`: `getBlock`/`setBlock` for modifying chunk data; `setBlock` also marks chunk as modified for persistence/replication.
       - `getOrCreateChunk.ts`: Retrieves/generates chunks, utilizing `ChunkGenerationQueue`.
       - `chunkGenerationQueue.ts`: Manages asynchronous chunk generation and initial collider building for new chunks.
       - `chunkGC.ts`: `sweepInactiveChunks` for garbage collecting unused chunks and their colliders.
     - `ecs/world.js`: Server-side ECS definitions (`bitecs`).
   - `render/`: Client-side rendering utilities (`Highlight.ts`).
   - `utils/`: Client-side utility functions (`raycastVoxel.ts`).
   - `generated/flatbuffers/`: Generated FlatBuffers TypeScript code.
   - `schema/game.fbs`: FlatBuffers schema definition.

3. Key Game Mechanics & Systems Status

   - ECS & Scene Graph: Client-side `bitecs` for entities like player. Server-side `bitecs` for player representation. Three.js for rendering.
   - Camera Control (Client): FPS/TPS modes functional. Advanced features pending.
   - Player Movement (Client & Server):
     - Client: `PlayerMovementSystem` for local input processing. `NetworkManager` for prediction/reconciliation against server state.
     - Server: Receives `PlayerInput` (FlatBuffers). Applies movement intent to Rapier player bodies using `setLinvel`. `checkIsOnGround` raycast for grounded state. Flying mode supported.
   - Terrain Generation & Chunk Management:
     - Server: `ChunkGenerationQueue` handles procedural generation. Chunks include voxel data and heightmaps.
     - Client: `ChunkManager` requests chunks from server. Visual meshing by `MesherManager` (simple block-by-block).
   - Networking (Client/Server):
     - WebSocket communication. FlatBuffers for `PlayerInput` and `ServerSnapshot`. JSON for other messages (chunk requests/responses, block updates, errors).
     - Client-side prediction and server reconciliation for player movement implemented.
     - Authoritative server for block mining/placing and physics.
   - Block Interaction (Mining/Placing):
     - Client: Raycasting for targeting. Sends commands to server. Optimistic local updates for placing (visual only).
     - Server: Authoritative. `MINE_BLOCK`/`PLACE_BLOCK` handlers update voxel data, then trigger immediate removal of old colliders and a full rebuild of greedy colliders for the affected chunk. Broadcasts RLE-encoded `blockUpdate` to clients.
     - **Current Major Issue:** Player can walk on air where blocks (especially original, world-generated ones) were mined. This is the primary focus of ongoing debugging, centering on the greedy collider generation in `buildChunkColliders.ts`.
   - Server-Side Physics:
     - Rapier3D for physics simulation (stepped at 30Hz).
     - Greedy meshing in `buildChunkColliders.ts` creates large, optimized colliders for terrain.
     - Player physics bodies are capsules.
     - `isBlockExposed` logic (including "air below" check) in `buildChunkColliders.ts` is intended to ensure correct mesh generation after mining.

4. Notable Discrepancies from Tech Spec / TODOs (Prioritized):

   1.  **Greedy Collider Behavior on Mining (CRITICAL BLOCKER):**
       -   Tech Spec: Robust physics.
       -   Current: Despite correct voxel data updates and `isBlockExposed` logic, players can still walk on air after mining certain blocks. The greedy colliders generated by `buildChunkColliders.ts` appear to be "papering over" the holes in some situations. This is the highest priority bug.
       -   Recommendation: Intensive debugging of `buildChunkColliders.ts` greedy meshing logic (expansion phases X, Z, Y) and the conditions under which meshes are started and shaped, especially around mined blocks.

   2.  **Networking - Broader FlatBuffers Integration (High Priority):**
       -   Tech Spec: FlatBuffers for binary data.
       -   Current: S0-1 (FlatBuffers for `PlayerInput`/`ServerSnapshot`) is COMPLETE. JSON still used for other messages like chunk data, block updates.
       -   Recommendation: Expand FlatBuffers use to other high-traffic messages (e.g., chunk data, block updates) for performance.

   3.  **Client-Side Visual Meshing - Greedy Meshing (Medium Priority):**
       -   Tech Spec: Greedy mesher worker (SURF algorithm) for client visuals.
       -   Current: `mesherWorker.ts` (client visuals) uses simple block-by-block. Server-side *colliders* use greedy meshing.
       -   Recommendation: Implement greedy meshing for client-side visual meshes to reduce vertex count, improve rendering performance, and align better with server physics geometry.

   4.  **Server-Side Physics Refinement (Medium Priority):**
       -   Tech Spec: Authoritative server simulates physics at 30 Hz.
       -   Current: Player movement uses direct `setLinvel`. A more sophisticated physics interaction model (e.g., applying forces, better handling of collisions) could be beneficial.
       -   Recommendation: Explore more advanced Rapier features for player character control if current `setLinvel` approach proves limiting.

   5.  **Chunk Management & Rendering (Medium Priority):**
       -   Tech Spec: Texture Atlas & Renderer, frustum culling, LOD swap refinement.
       -   Current: Basic chunk rendering. `ChunkManager` has LOD logic. Texture atlas not implemented.
       -   Recommendation: Implement texture atlas. Refine client-side culling and LOD transitions.

   6.  **Lobby Lifecycle & Match Management (Medium Priority - Tech Spec M5):**
       -   Tech Spec: Lobby registry, /create endpoint, WebSocket handshake with lobby ID, heartbeats, reconnect logic, auto-terminate empty lobby.
       -   Current: `matchServer.ts` is a single match instance. No lobby system or multi-match management. Basic player connect/disconnect.
       -   Recommendation: Implement the lobby system as per M5 tasks.

   7.  **Camera System Refinements (Medium Priority - Tech Spec C5-C7):**
       -   C5 (TPS): Basic TPS is in `CameraSystem.ts`. `InputLookSystem` needs TPS mouse handling (zoom). `main.tsx` needs FPS/TPS toggle key.
       -   C6 (Lerping): Smooth camera movement for FPS/TPS is pending.
       -   C7 (Collision/Occlusion): Camera collision and occlusion handling is pending.
       -   Recommendation: Implement these refinements in `CameraSystem.ts` and `InputLookSystem.ts`.

   8.  **RLE for Block Updates (Low Priority):**
        -  `encodeChunkDiff` is used for `blockUpdate` messages, providing a basic RLE.
        - Tech Spec mentions chunk diff optionally LZ4 (post-MVP).
        - Recommendation: Current RLE is likely sufficient for now. LZ4 is a future optimization.

5. Key Issues & Recommendations (Overall Priority Order):

   1.  **FIX COLLIDER BUG (CRITICAL BLOCKER):** Resolve the "walking on air over mined blocks" issue. This requires deep analysis of the greedy meshing in `buildChunkColliders.ts` and its interaction with the `isBlockExposed` logic, especially when mining original terrain blocks.
   2.  **Networking - Broader FlatBuffers Integration (HIGH):** Integrate S0-1 work more broadly.
   3.  **Client-Side Visual Greedy Meshing (HIGH):** For performance and visual/physics consistency.
   4.  **Server-Side Physics Refinement (MEDIUM):** Improve player physics interactions if needed.
   5.  **Lobby & Match Management (MEDIUM):** For multiplayer.
   6.  **Camera System Refinements (MEDIUM):** Polish player experience.
   7.  **Chunk Rendering & Texture Atlas (MEDIUM):** Improve visual fidelity.
   8.  **Server Stability & State Broadcasting (MEDIUM):** `broadcastState` is functional. Ongoing monitoring.
   9.  **Code Cleanup & Refinement (ONGOING):** Review `InputHandler.ts`, ensure constant consistency, refine client prediction if issues arise.

(This document should be regularly updated as the project evolves. Timestamp and versioning are recommended.)

6. Development Learnings & LLM Guidance

   This section captures broader learnings from the development process that may be useful for future AI assistants or human developers joining the project.

   *   **External Tooling & Environment:**
       *   Be prepared for challenges with external tools like compilers (`flatc`) or runtimes.
       *   Environment variable issues can be subtle.
       *   Build tool configurations might need adjustments for debugging.

   *   **Library Integration & Debugging (e.g., FlatBuffers `BigInt` issue):**
       *   Pay close attention to version compatibility, compiler flags, and usage patterns.
       *   The "Triage Kit" / isolated test case approach is highly effective.
       *   Iterative debugging with extensive logging is key.

   *   **Client vs. Server Context:**
       *   Be mindful of distinct client and server codebases and contexts.

   *   **Project Evolution & Documentation:**
       *   This overview is a living document. Refer to conversation history for the absolute latest state if discrepancies are suspected.

   *   **Task Milestones:**
       *   Development is structured around milestones.

   *   **Collider Debugging Cycle (Recent Learning):**
       *   The process of debugging physics colliders, especially with greedy meshing, often involves:
           1.  Modifying server-side generation logic (`buildChunkColliders.ts`, `isBlockExposed`).
           2.  Ensuring voxel data is correctly updated *before* collider rebuild (`voxelIO.ts`, `matchServer.ts` handlers).
           3.  Adding detailed server logs for collider parameters and voxel states at critical points.
           4.  Client-side testing to reproduce the behavior.
           5.  Analyzing server logs against observed client behavior to pinpoint discrepancies.
       *   Small changes in meshing or exposure logic can have complex, non-obvious impacts on the final physics shapes. Careful, iterative testing and logging are essential.

7. LLM Instruction Set

   This section is for providing specific instructions or configurations on how the LLM assistant should behave to best assist with the project.

   *   **Example Configuration Directives:**
       *   `New llmconfig: Never assume you know a piece of code, and never guess. always double check and be pinpoint accurate with your research.`
       *   *(User can add more general or temporary instructions here as needed)*

**MILESTONE S1: SERVER-SIDE WORLD & CHUNK MANAGEMENT**

*   **S1-1: Server ECS Bootstrap & Heightmap Consistency Test - COMPLETE**
    *   **Server ECS Integration (`src/server/ecs/world.ts`, `src/server/matchServer.ts`):**
        *   The `bitecs` library has been installed.
        *   A server-side ECS world is now initialized in `matchServer.ts` using `createServerECSWorld` (from `src/server/ecs/world.js`).
        *   Server-side components (`Position`, `Rotation`, `Velocity`, `NetworkId`) are defined in `src/server/ecs/world.js`.
        *   On new player connection (`wss.on('connection'`), an ECS entity is created for the player using `addEntity(matchState.ecsWorld)`.
        *   Components (`Position`, `Rotation`, `Velocity`, `NetworkId`) are added to this entity, and their initial values are set (e.g., `Position.x[playerEntityId] = newPlayer.position.x`).
        *   `NetworkId.id` is populated with a unique, incrementing numeric ID.
        *   On player disconnection (`ws.on('close')`), the corresponding ECS entity is removed using `removeEntity(matchState.ecsWorld, player.entityId)`.
        *   The ECS world's time (`matchState.ecsWorld.time`) is updated in the main server game loop.
    *   **Client ECS Component Definition (Conceptual for S1-1, physical files created):**
        *   As part of the S1-1 milestone, the following client-side ECS components were also designed and their files initially created in `src/ecs/components/`. While server-side ECS integration took immediate precedence, these are relevant to the overall ECS plan:
            *   `Transform.ts`: Refactored from `src/ecs/world.ts` to its own file. This is a core client-side component.
            *   `Velocity.ts`: For client-side representation of velocity ({ x, y, z: Types.f32 }).
            *   `PlayerInput.ts`: For capturing client-side input state ({ moveFlags: Types.ui8, mouseDeltas: Types.f32, sequenceNumber: Types.ui32 }).
            *   `PhysicsBodyId.ts`: For linking client ECS entities to physics representations ({ id: Types.ui32 }).
            *   `NetworkId.ts`: For linking client ECS entities to server/network identifiers ({ id: Types.ui32 }).
    *   **Heightmap Consistency Test (`src/server/world/chunkValidation.ts`, `matchServer.ts`):**
        *   Implemented `testS1_1_HeightmapConsistency` to compare server-generated chunk heightmaps (from `genChunk.ts`) against a replication of client logic.
        *   **Initial Failures & Debugging:**
            1.  Server's `genChunk.ts` initially produced flat heightmaps.
            2.  Refactored `genChunk.ts` and `src/server/world/heightAt.ts` to use new shared noise constants (`src/shared/terrainConsts.ts`) and a specific multi-octave noise formula (`makeNoise2D` with `mulberry32` PRNG for deterministic seeding).
            3.  Aligned `replicateClientHeightmapGen` in `chunkValidation.ts` with this new "mommy engineer" terrain specification.
        *   **Outcome:** Test now PASSES, confirming server can generate chunk (0,0) with a heightmap identical to the client's updated specification.

*   **S1-2: Pre-warm Initial Chunks (Server) - COMPLETE** (Though may be toggled for testing)
    *   Implemented in `matchServer.ts` to generate a 3x3 chunk area around (0,0) on server startup using `genChunk`.
    *   Logs timing and success. (Currently commented out to facilitate S1-3 on-demand loading tests).

*   **S1-3: On-Demand Chunk Loader (Server Logic & Client Integration) - COMPLETE**
    *   **Server-Side Logic (Previously Implemented):**
        *   `src/server/world/getOrCreateChunk.ts`: Contains `getOrCreateChunk(state, seed, cx, cz)` which calls `genChunk` if a chunk is missing and caches it in `matchState.chunks`.
        *   `src/server/world/voxelIO.ts`: `getBlock` and `setBlock` were updated to use `getOrCreateChunk`, making block modifications trigger on-demand generation.
        *   `src/server/matchServer.ts`: Implemented a `chunkRequest` message handler that uses `getOrCreateChunk` to fetch/generate chunk data and sends it back to the client in a `chunkResponse` message (voxel data as `Array.from(chunk.data)`).
    *   **Client-Side Integration (`src/world/ChunkManager.ts`, `src/net/NetworkManager.ts`, `src/net/WebSocketClient.ts`):**
        *   **Goal:** Client requests chunk data from the server for rendering new areas, instead of relying solely on its local `NoiseManager` for generation.
        *   **`ChunkManager.ts` Modifications:**
            *   Constructor now accepts a `WebSocket | null` instance (passed as `null` from `main.tsx` initially).
            *   Added `public setSocket(socket: WebSocket)` method, allowing `NetworkManager` to provide the live socket post-connection.
            *   `loadChunk()` method now calls a new private method `requestChunkDataFromServer(cx, cz, lodLevel)`.
            *   `requestChunkDataFromServer()`:
                *   Sends a `chunkRequest` JSON message (e.g., `{ type: 'chunkRequest', cx, cz }`) to the server via the WebSocket.
                *   Manages pending requests using a `Map` (`pendingChunkRequests`) storing Promises, to avoid redundant requests and handle server responses.
                *   Includes a 10-second timeout for server responses. On timeout (or if WebSocket is initially unavailable), it falls back to local generation using `this.noiseManager.generateChunk()`.
            *   Added `public handleChunkResponse(cx, cz, voxels)`:
                *   Called by `NetworkManager` when a `chunkResponse` message is received from the server.
                *   Creates a new `Chunk` object.
                *   Populates the chunk's voxel data using `chunk.setData(new Uint8Array(voxels))`.
                *   Resolves the corresponding Promise in `pendingChunkRequests`.
            *   Added `public handleChunkResponseError(cx, cz, reason)`:
                *   Called by `NetworkManager` for `chunkResponseError` messages.
                *   Rejects the corresponding Promise.
        *   **`NetworkManager.ts` Modifications:**
            *   Constructor updated to pass an `onOpenCallback` to `WebSocketClient`.
            *   This `onOpenCallback` is: `(socket) => { if (this.chunkManager) { this.chunkManager.setSocket(socket); } }`.
            *   The main `wsClient.onMessage` handler in `NetworkManager` now checks for message types `chunkResponse` and `chunkResponseError`. If detected, it calls `this.chunkManager.handleChunkResponse(...)` or `this.chunkManager.handleChunkResponseError(...)` respectively.
        *   **`WebSocketClient.ts` Modifications:**
            *   Constructor now accepts an optional `onOpenCallback: (socket: WebSocket) => void`.
            *   In its internal `this.ws.onopen` handler, if this callback is provided, it's called with the active `WebSocket` instance.
    *   **Verification:**
        *   Server logs confirm receipt of `chunkRequest` from client, generation/caching by `getOrCreateChunk`, and sending of `chunkResponse`.
        *   Client logs confirm sending of `chunkRequest`, receipt and processing of `chunkResponse` from server, and subsequent loading/meshing of the chunk using server-provided data.
        *   Fallback to local generation on timeout/no-socket was also included in the `ChunkManager` logic.
        *   This makes chunk loading for viewing server-authoritative, fulfilling S1-3.

6. Development Learnings & LLM Guidance (New Section)

   This section captures broader learnings from the development process that may be useful for future AI assistants or human developers joining the project.

   *   **External Tooling & Environment:**
       *   Be prepared for challenges with external tools like compilers (`flatc`) or runtimes. Manual downloads, specific version requirements, and platform-specific binaries are sometimes necessary.
       *   Environment variable issues (e.g., `TS_NODE_COMPILER_OPTIONS`) can be subtle and may require simple but non-obvious fixes like restarting terminals or IDEs.
       *   Build tool configurations (e.g., `vitest.config.ts`) might need adjustments (`silent: false`, `exclude` paths) to aid debugging by making logs more visible or by correctly scoping test execution.

   *   **Library Integration & Debugging (e.g., FlatBuffers `BigInt` issue):**
       *   When integrating new libraries, especially for complex features like binary serialization, pay close attention to:
           *   **Version Compatibility:** Ensure the library version matches examples or known-good configurations. Mismatches (e.g., FlatBuffers runtime `^25.x` vs `^23.5.26`) can lead to silent failures or unexpected behavior.
           *   **Compiler/Generator Flags:** Critical features might depend on specific flags (e.g., `--gen-object-api` for FlatBuffers `BigInt` handling with the Object API).
           *   **Usage Patterns:** Adhere to recommended usage patterns from official documentation or reliable examples, especially if multiple APIs exist within the library (e.g., FlatBuffers VTable access vs. Object API).
       *   **"Triage Kit" Approach:** When facing persistent issues with a library, creating a minimal, isolated test case or "probe script" (like `scratch/fb_int64_probe.ts`) can be highly effective. This helps determine if the problem lies in the library itself, its configuration, or its interaction with the broader project.
       *   **Iterative Debugging:** Expect an iterative process. Use logging extensively, try different approaches, and consult documentation or community resources.

   *   **Client vs. Server Context:**
       *   The project involves distinct client-side (`src/`) and server-side (`src/server/`) codebases. Be mindful of which context is being discussed or modified.
       *   Features like ECS are being implemented on both client and server, but their components and systems might differ. For example, `src/ecs/components/` primarily contains client-side definitions, while server-side ECS components are co-located with the server's ECS world definition (e.g., `src/server/ecs/world.js`).

   *   **Project Evolution & Documentation:**
       *   This `project_overview_for_llm.txt` is a living document. As new features are added or issues resolved, updating this overview with key decisions, learnings, and current status is crucial for maintaining context for AI assistants and team members.
       *   Refer to commit history and user summaries for recent changes if the document seems out of sync.

   *   **Task Milestones:**
       *   Development is structured around milestones (e.g., S0-1, S1-1, S1-2, S1-3). Refer to these when discussing progress or planning next steps. 