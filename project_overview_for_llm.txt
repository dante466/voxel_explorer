Voxel Explorer Project Overview for LLMs (Last Updated: {TODAY'S_DATE} - AI Assisted Review)

This document provides a detailed breakdown of the Voxel Explorer game project, based on its codebase, technical specification, and current implementation status.

0. Vision & Scope
A hyper-performant, desktop-web voxel game with procedurally generated terrain. The authoritative server simulates physics (target 30 Hz), and the client targets 60 FPS. MVP focuses on exploration, mining, and building. Future scope includes multiplayer (up to 10 players), resources, and combat.

1. Core Technologies
   - Rendering: Three.js (WebGL2) using `vite` for bundling.
   - Physics: Server-side authoritative with Rapier3D (WASM). Client-side movement prediction and reconciliation.
   - Networking: Raw WebSockets (Client: native `WebSocket`, Server: `'ws'` library). JSON for messages (FlatBuffers planned).
   - Language: TypeScript.
   - ECS: `'bitecs'` library for client-side entity and component management.
   - World Generation: Web Workers for noise (`fast-simplex-noise`) and meshing.

2. Project Structure (`src/`)

   - `main.tsx`: Main client-side entry point. Initializes Three.js scene, ECS world, systems, game loop, core managers (`ChunkManager`, `NetworkManager`, `NoiseManager`, `MesherManager`), debug UI, and global event listeners (keyboard, mouse for interactions).
   - `ecs/`: Entity Component System (client-side).
     - `world.ts`: Defines `bitecs` world factory (`createECSWorld`) and the core `Transform` component (position, rotation, scale).
     - `types.ts`: Contains shared ECS types (e.g., `CameraMode`).
     - `components/`:
       - `CameraTarget.ts`: Defines the `CameraTarget` component (mode, zoom, pitch, yaw) for entities the camera should follow or be controlled by.
     - `systems/`:
       - `transformSystem.ts`: Syncs ECS `Transform` (position, rotation) to Three.js `Object3D` properties. Manages a map (`object3DMap`) of entity IDs to `Object3D` instances.
       - `CameraSystem.ts`: Manages the main `THREE.PerspectiveCamera` and its pivot `Object3D`. Updates camera based on `CameraTarget` of the player entity. Implements FPS and basic TPS camera logic.
       - `inputLookSystem.ts`: Listens for `mousemove` (when pointer locked) and updates `CameraTarget.yaw` and `CameraTarget.pitch` for the player entity.
       - `PlayerMovementSystem.ts`: Handles keyboard inputs (WASD, Space, Shift, Arrows, F for fly toggle). Updates the player entity's `Transform.position` based on inputs, `CameraTarget.yaw`, and delta time. Implements ground mode (gravity, jump using `ChunkManager.getHeightAtPosition`) and flying mode.
   - `world/`: Client-side voxel world logic.
     - `Chunk.ts`: Defines `CHUNK_SIZE`, `LOD_CHUNK_SIZE`, `LODLevel`. `Chunk` class stores voxel data (`Uint8Array`), manages LOD-specific dimensions, and provides heightmap access. (RLE compression mentioned in old overview, current status needs verification in code).
     - `noiseWorker.ts`: Web Worker using `fast-simplex-noise` for deterministic procedural terrain generation based on chunk coordinates and LOD level. Outputs voxel data and heightmap.
     - `NoiseManager.ts`: Manages `noiseWorker.ts` for asynchronous chunk data generation.
     - `mesherWorker.ts`: Web Worker for generating chunk meshes (simple block-by-block, face culling). (Greedy meshing is a TODO).
     - `MesherManager.ts`: Manages `mesherWorker.ts` for asynchronous mesh generation.
     - `ChunkManager.ts`: Orchestrates client-side chunk loading/unloading, LOD switching based on distance and hysteresis, and meshing. Manages `Chunk` data and `THREE.Mesh` instances. Provides `getHeightAtPosition` for player-terrain interaction and `setBlock` for client-side prediction of block changes.
   - `net/`: Client-side networking.
     - `WebSocketClient.ts`: Manages the WebSocket connection, sending commands (currently JSON, FlatBuffers planned) and receiving messages from the server.
     - `types.ts`: Defines client-side network-related types (e.g., `ClientCommand`, `ClientCommandType`, connection states).
     - `InputHandler.ts`: Captures mouse delta for look controls. Its broader role for other inputs seems to be superseded by ECS systems.
     - `NetworkManager.ts`: Coordinates client-side networking.
       - Constructor takes ECS `world`, `playerEntityId`, `movementSystemControls` (for current input state), and `chunkManager` (for prediction and block updates).
       - `setupMessageHandler`: Handles server messages:
         - `stateUpdate`: Updates player entity's `Transform` (position, rotation) to server state. Implements client-side prediction reconciliation by removing acknowledged inputs from `pendingInputs` and replaying subsequent inputs using `calculatePlayerMovement`.
         - `blockUpdate`: Updates chunk data via `ChunkManager.setBlock` based on server-confirmed block changes.
         - `mineError`/`placeError`: Logs errors from server.
       - `sendMineCommand`/`sendPlaceCommand`: Sends block modification requests to the server.
       - `startCommandLoop`: Periodically sends `PLAYER_INPUT` commands to the server (30 Hz) containing current key states, mouse deltas, and camera yaw. Stores these inputs in `pendingInputs` for reconciliation.
   - `server/`: Server-side logic.
     - `matchServer.ts`: Main server application using Express and `ws` for WebSockets.
       - Initializes Rapier physics (`createPhysicsWorld`).
       - Manages `MatchState` (players, chunks).
       - Handles client connections, assigns player IDs.
       - `handleMessage`: Processes client commands:
         - `PLAYER_INPUT`: Updates `lastProcessedInputSeq` for the player. (Full physics-based movement update is a TODO).
         - `MINE_BLOCK`/`PLACE_BLOCK`: Validates commands (bounds, basic checks), updates server-side chunk data (`getBlock`/`setBlock` helpers), and broadcasts `blockUpdate` messages to all clients. Sends `mineError`/`placeError` on failure.
       - Periodically broadcasts game state to clients (TODO: `broadcastState` function seems to be defined but not called in the provided snippet).
     - `physics.ts`: Wrapper for Rapier3D initialization (`initRapier`, `createPhysicsWorld`). (Detailed physics simulation loop and entity management not fully shown in snippet).
     - `types.ts`: Defines server-side data structures (e.g., `MatchState`, `Player`, `Chunk`).
   - `render/`: Client-side rendering utilities.
     - `Highlight.ts`: `VoxelHighlighter` class to render a wireframe box around a targeted voxel using `THREE.LineSegments`. Used in `main.tsx`.
   - `utils/`: Client-side utility functions.
     - `raycastVoxel.ts`: Implements voxel raycasting (DDA algorithm) to convert screen clicks/center screen to voxel coordinates and face normals. Used for block interaction.
   - `scenes/`: Exists but appears empty or unused.
   - `main.ts`: Legacy entry point, likely from scaffolding. `main.tsx` is the current primary entry point.
   - `style.css`: Basic CSS.

3. Key Game Mechanics & Systems Status

   - ECS & Scene Graph: `bitecs` for client-side ECS. Three.js for rendering.
     - Player entity has `Transform`, `CameraTarget`, and `Object3DRef` (links to `playerModelMesh`).
     - `transformSystem` syncs ECS `Transform` to Three.js `Object3D`s.
   - Camera Control (Client):
     - `CameraSystem` updates the main camera based on player's `Transform` and `CameraTarget` (yaw/pitch for FPS, zoom/pitch/yaw for TPS).
     - `inputLookSystem` updates `CameraTarget.yaw` and `CameraTarget.pitch` from mouse input.
     - `PlayerMovementSystem` uses `CameraTarget.yaw` for movement direction.
     - Basic FPS and TPS modes are implemented. Lerping and advanced collision/occlusion are pending (Tech Spec C6-C7).
   - Player Movement (Client & Server):
     - Client: `PlayerMovementSystem` handles keyboard input, calculates intended movement (including gravity/jump in ground mode using `ChunkManager.getHeightAtPosition`), and updates local `Transform`. Flying mode implemented.
     - Client: `NetworkManager` sends input commands, performs client-side prediction by replaying inputs after receiving server state, and snaps to server state.
     - Server: `matchServer.ts` receives inputs. Basic position updates based on input are present; full server-side physics simulation with Rapier for player movement is a major TODO.
   - Terrain Generation & Chunk Management (Client):
     - `ChunkManager` loads/unloads chunks and manages LODs (HIGH/LOW) based on distance to player.
     - `NoiseManager` + `noiseWorker` generate chunk voxel data procedurally.
     - `MesherManager` + `mesherWorker` generate simple block-by-block meshes. Greedy meshing is a TODO.
     - `ChunkManager.getHeightAtPosition` is used for ground collision by `PlayerMovementSystem`.
   - Networking (Client/Server):
     - `NetworkManager` (client) communicates with `matchServer.ts` (server) via WebSockets using JSON messages.
     - Client-side prediction and server reconciliation for player movement is implemented.
     - Authoritative server for block mining/placing: client sends command, server validates, updates its state, and broadcasts to all clients.
     - FlatBuffers for network messages is a TODO.
   - Block Interaction (Mining/Placing):
     - Client: `raycastVoxel` determines target block. `VoxelHighlighter` shows selection.
     - Client: `main.tsx` handles mouse clicks to initiate mine/place actions, calling `NetworkManager.sendMineCommand` or `sendPlaceCommand`.
     - Client: `ChunkManager.setBlock` is used for optimistic local updates on block placement (though server is authoritative).
     - Server: `matchServer.ts` validates and executes block changes, then broadcasts.
   - Server-Side Physics:
     - Rapier3D is initialized on the server (`physics.ts`, `matchServer.ts`).
     - TODO: Full integration of Rapier for authoritative player movement, collision detection, and other physics-driven interactions.

4. Notable Discrepancies from Tech Spec / TODOs (Prioritized):

   1.  **Server-Side Physics & Player Movement (High Priority):**
       -   Tech Spec: Authoritative server simulates physics at 30 Hz.
       -   Current: `matchServer.ts` has basic input handling but lacks full Rapier physics integration for player movement, collision, and state updates. `PlayerMovementSystem.ts` on client is more advanced.
       -   Recommendation: Implement server-side player entity management, apply inputs to physics bodies, step Rapier world, and broadcast authoritative states.

   2.  **Networking - FlatBuffers & Optimization (Initial Bootstrap S0-1 COMPLETE, Integration Pending):**
       -   Tech Spec: FlatBuffers for binary data, chunk diff LZ4 (post-MVP).
       -   Current: JSON messaging for primary communication.
       -   **S0-1 Milestone (FlatBuffers Bootstrap) - COMPLETE:**
           -   **Setup:** The `flatbuffers` npm package (version `^23.5.26`) was installed. The FlatBuffers compiler (`flatc`) was manually downloaded (Windows binary, version `23.5.26`) and placed at `E:\tools\flatc.exe`.
           -   **Schema & Generation:** A FlatBuffers schema (`src/schema/game.fbs`) defining `Vec3`, `PlayerState`, and `StateSnapshot` (root type) was created. TypeScript bindings were generated into `src/generated/flatbuffers/` using the command: `E:\tools\flatc.exe --ts --gen-object-api -o src/generated/flatbuffers src/schema/game.fbs`. The `--gen-object-api` flag proved crucial.
           -   **Implementation:** Helper functions (`encodeStateSnapshot`, `decodeStateSnapshot`) were implemented in `src/net/flat.ts` utilizing the generated Object API (e.g., `PlayerStateT`, `stateSnapshotT.pack(builder)`).
           -   **Testing:** Jest/Vitest tests were created in `src/net/flat.test.ts` to verify the encoding and decoding of `StateSnapshot`, including `PlayerState` arrays and, critically, the `timestamp` field (`Int64`).
           -   **Timestamp (`Int64`/`BigInt`) Issue Resolution (Key Learning):** An initial and significant issue where `timestamp` fields (schema type `long`, TS type `BigInt`) were always decoded as `0n` was resolved through a detailed debugging process:
               1.  **Correct Runtime Version:** Ensured the `flatbuffers` runtime dependency in `package.json` was `^23.5.26` (upgrading from an initial `^25.x` version which was incompatible or problematic).
               2.  **Compiler Flag:** Confirmed the necessity of the `--gen-object-api` flag during `flatc` compilation. Schemas generated without this flag did not correctly handle `BigInt` through the standard VTable-based accessors for `long` types in the context of the test setup.
               3.  **Object API Pattern:** The solution involved using the "Object API" pattern provided by FlatBuffers when `--gen-object-api` is used. This means creating instances of `XYZT` (e.g., `PlayerStateT`, `StateSnapshotT`), populating their fields, and then calling the `.pack(builder)` method on the root object. For decoding, the `getRootAsStateSnapshot(buffer).unpack()` method provides a plain JavaScript object with `BigInt` values correctly populated.
               4.  **Probe Script:** A minimal "probe script" (`scratch/fb_int64_probe.ts`) was used to isolate and confirm `BigInt` handling with the correct FlatBuffers version and Object API usage, outside the main project's test runner, which helped build confidence in the library itself.
               5.  **Environment Issues:** A transient issue with `ts-node` and a malformed `TS_NODE_COMPILER_OPTIONS` environment variable complicated early testing of the probe script; this was resolved by restarting the terminal.
               6.  **Vitest Configuration:** `vitest.config.ts` was adjusted (`silent: false`) to ensure `console.log` statements within the library code (or tests) were visible during debugging.
           -   **Current Status:** The FlatBuffers helper functions and tests are complete and pass, demonstrating correct serialization and deserialization of the defined schema, including `BigInt` timestamps.
       -   Recommendation: Integrate the created FlatBuffers (de)serialization helpers into the main client-server communication path (`src/net/NetworkManager.ts` / `src/net/WebSocketClient.ts` and `src/server/matchServer.ts`) to replace JSON for state updates and relevant commands. This is the next step for leveraging S0-1.

   3.  **Meshing - Greedy Meshing (Medium Priority):**
       -   Tech Spec: Greedy mesher worker (SURF algorithm).
       -   Current: `mesherWorker.ts` uses a simple block-by-block approach.
       -   Recommendation: Implement greedy meshing to significantly reduce vertex count and improve rendering performance.

   4.  **Chunk Management & Rendering (Medium Priority):**
       -   Tech Spec: Texture Atlas & Renderer, frustum culling, LOD swap refinement.
       -   Current: Basic chunk rendering with shared material. `ChunkManager` has LOD logic. Frustum culling in `ChunkManager.getVisibleChunks` is basic. Texture atlas not explicitly seen.
       -   Recommendation: Implement texture atlas for varied block types. Improve chunk rendering and culling. Refine LOD transitions.

   5.  **Camera System Refinements (Medium Priority - Tech Spec C5-C7):**
       -   C5 (TPS): Basic TPS is in `CameraSystem.ts`. `InputLookSystem` needs TPS mouse handling (zoom). `main.tsx` needs FPS/TPS toggle key.
       -   C6 (Lerping): Smooth camera movement for FPS/TPS is pending.
       -   C7 (Collision/Occlusion): Camera collision and occlusion handling is pending.
       -   Recommendation: Implement these refinements in `CameraSystem.ts` and `InputLookSystem.ts`.

   6.  **Lobby Lifecycle & Match Management (Medium Priority - Tech Spec M5):**
       -   Tech Spec: Lobby registry, /create endpoint, WebSocket handshake with lobby ID, heartbeats, reconnect logic, auto-terminate empty lobby.
       -   Current: `matchServer.ts` is a single match instance. No lobby system or multi-match management. Basic player connect/disconnect.
       -   Recommendation: Implement the lobby system as per M5 tasks.

   7.  **Player Input Handling - `InputHandler.ts` Review (Low-Medium Priority):**
       -   Current: `InputHandler.ts` role seems reduced. `PlayerMovementSystem` and `InputLookSystem` handle primary game inputs.
       -   Recommendation: Review `InputHandler.ts`. Consolidate input logic into ECS systems if possible, or clarify its specific remaining responsibilities (e.g., UI interactions not tied to ECS).

   8.  **World Persistence & Data (Low Priority for MVP):**
       -   Tech Spec: "Persistence / $: None" for MVP.
       -   Current: No persistence. Server `matchState` is in-memory.
       -   Recommendation: This is fine for MVP.

   9.  **Missing Directories from Spec (Low Priority):**
       -   `src/render/` is partially present (`Highlight.ts`). More components like shaders, chunk renderer, atlas management are expected per spec.
       -   `src/utils/` is present (`raycastVoxel.ts`).
       -   Recommendation: Organize rendering code into `src/render/` as it develops.

   10. **RLE Compression for Chunks (Low Priority):**
        -  `Chunk.ts` mentions RLE in old overview, but current implementation detail for compression/decompression needs verification if it exists or is used.
        - Tech Spec mentions chunk diff optionally LZ4 (post-MVP).
        - Recommendation: Confirm if RLE is actively used for chunk data. Consider LZ4 for diffs later.

5. Key Issues & Recommendations (Overall Priority Order - Combining above with general observations):

   1.  **Server-Side Authoritative Player Movement & Physics (CRITICAL):** The largest gap for core gameplay. Implement full Rapier physics on the server for player movement, collisions, and state updates. (Corresponds to #1 in TODOs)
   2.  **Networking Enhancements - FlatBuffers Integration (HIGH):** Essential for performance and scalability as per tech spec. Integrate the S0-1 FlatBuffers bootstrap into the live communication pipeline. (Corresponds to #2 in TODOs)
   3.  **Greedy Meshing (HIGH):** Critical for client rendering performance with larger views or more complex chunks. (Corresponds to #3 in TODOs)
   4.  **Lobby & Match Management (MEDIUM-HIGH):** Required for multiplayer matches as envisioned in tech spec. (Corresponds to #6 in TODOs)
   5.  **Camera System Refinements (MEDIUM):** Polish player experience (TPS controls, lerping, collision). (Corresponds to #5 in TODOs)
   6.  **Chunk Rendering & Texture Atlas (MEDIUM):** Improve visual fidelity and performance. (Corresponds to #4 in TODOs)
   7.  **Server Stability & State Broadcasting (MEDIUM):** Ensure `broadcastState` is robustly implemented and called in `matchServer.ts`. Solidify error handling and resource management on the server.
   8.  **Code Cleanup & Refinement (ONGOING):**
       - Review `InputHandler.ts` role.
       - Ensure consistency in client/server constants (chunk sizes, etc.).
       - Address any remaining client-side prediction inaccuracies, especially around `yVelocity` in `NetworkManager.ts` reconciliation. The comment "This is a known simplification for now" regarding yVelocity implies it's an area for improvement.

(This document should be regularly updated as the project evolves. Timestamp and versioning are recommended.) 

**MILESTONE S1: SERVER-SIDE WORLD & CHUNK MANAGEMENT**

*   **S1-1: Server ECS Bootstrap & Heightmap Consistency Test - In Progress (Server-side ECS integrated, Client-side components defined)**
    *   **Server ECS Integration (`src/server/ecs/world.ts`, `src/server/matchServer.ts`):**
        *   The `bitecs` library has been installed.
        *   A server-side ECS world is now initialized in `matchServer.ts` using `createServerECSWorld` (from `src/server/ecs/world.js`).
        *   Server-side components (`Position`, `Rotation`, `Velocity`, `NetworkId`) are defined in `src/server/ecs/world.js`.
        *   On new player connection (`wss.on('connection'`), an ECS entity is created for the player using `addEntity(matchState.ecsWorld)`.
        *   Components (`Position`, `Rotation`, `Velocity`, `NetworkId`) are added to this entity, and their initial values are set (e.g., `Position.x[playerEntityId] = newPlayer.position.x`).
        *   `NetworkId.id` is populated with a unique, incrementing numeric ID.
        *   On player disconnection (`ws.on('close')`), the corresponding ECS entity is removed using `removeEntity(matchState.ecsWorld, player.entityId)`.
        *   The ECS world's time (`matchState.ecsWorld.time`) is updated in the main server game loop.
    *   **Client ECS Component Definition (Conceptual for S1-1, physical files created):**
        *   As part of the S1-1 milestone, the following client-side ECS components were also designed and their files initially created in `src/ecs/components/`. While server-side ECS integration took immediate precedence, these are relevant to the overall ECS plan:
            *   `Transform.ts`: Refactored from `src/ecs/world.ts` to its own file. This is a core client-side component.
            *   `Velocity.ts`: For client-side representation of velocity ({ x, y, z: Types.f32 }).
            *   `PlayerInput.ts`: For capturing client-side input state ({ moveFlags: Types.ui8, mouseDeltas: Types.f32, sequenceNumber: Types.ui32 }).
            *   `PhysicsBodyId.ts`: For linking client ECS entities to physics representations ({ id: Types.ui32 }).
            *   `NetworkId.ts`: For linking client ECS entities to server/network identifiers ({ id: Types.ui32 }).
    *   **Heightmap Consistency Test (`src/server/world/chunkValidation.ts`, `matchServer.ts`):**
        *   Implemented `testS1_1_HeightmapConsistency` to compare server-generated chunk heightmaps (from `genChunk.ts`) against a replication of client logic.
        *   **Initial Failures & Debugging:**
            1.  Server's `genChunk.ts` initially produced flat heightmaps.
            2.  Refactored `genChunk.ts` and `src/server/world/heightAt.ts` to use new shared noise constants (`src/shared/terrainConsts.ts`) and a specific multi-octave noise formula (`makeNoise2D` with `mulberry32` PRNG for deterministic seeding).
            3.  Aligned `replicateClientHeightmapGen` in `chunkValidation.ts` with this new "mommy engineer" terrain specification.
        *   **Outcome:** Test now PASSES, confirming server can generate chunk (0,0) with a heightmap identical to the client's updated specification.

*   **S1-2: Pre-warm Initial Chunks (Server) - COMPLETE (but temporarily disabled for S1-3 testing)**
    *   Implemented in `matchServer.ts` to generate a 3x3 chunk area around (0,0) on server startup using `genChunk`.
    *   Logs timing and success. (Currently commented out to facilitate S1-3 on-demand loading tests).

*   **S1-3: On-Demand Chunk Loader (Server Logic & Client Integration) - COMPLETE**
    *   **Server-Side Logic (Previously Implemented):**
        *   `src/server/world/getOrCreateChunk.ts`: Contains `getOrCreateChunk(state, seed, cx, cz)` which calls `genChunk` if a chunk is missing and caches it in `matchState.chunks`.
        *   `src/server/world/voxelIO.ts`: `getBlock` and `setBlock` were updated to use `getOrCreateChunk`, making block modifications trigger on-demand generation.
        *   `src/server/matchServer.ts`: Implemented a `chunkRequest` message handler that uses `getOrCreateChunk` to fetch/generate chunk data and sends it back to the client in a `chunkResponse` message (voxel data as `Array.from(chunk.data)`).
    *   **Client-Side Integration (`src/world/ChunkManager.ts`, `src/net/NetworkManager.ts`, `src/net/WebSocketClient.ts`):**
        *   **Goal:** Client requests chunk data from the server for rendering new areas, instead of relying solely on its local `NoiseManager` for generation.
        *   **`ChunkManager.ts` Modifications:**
            *   Constructor now accepts a `WebSocket | null` instance (passed as `null` from `main.tsx` initially).
            *   Added `public setSocket(socket: WebSocket)` method, allowing `NetworkManager` to provide the live socket post-connection.
            *   `loadChunk()` method now calls a new private method `requestChunkDataFromServer(cx, cz, lodLevel)`.
            *   `requestChunkDataFromServer()`:
                *   Sends a `chunkRequest` JSON message (e.g., `{ type: 'chunkRequest', cx, cz }`) to the server via the WebSocket.
                *   Manages pending requests using a `Map` (`pendingChunkRequests`) storing Promises, to avoid redundant requests and handle server responses.
                *   Includes a 10-second timeout for server responses. On timeout (or if WebSocket is initially unavailable), it falls back to local generation using `this.noiseManager.generateChunk()`.
            *   Added `public handleChunkResponse(cx, cz, voxels)`:
                *   Called by `NetworkManager` when a `chunkResponse` message is received from the server.
                *   Creates a new `Chunk` object.
                *   Populates the chunk's voxel data using `chunk.setData(new Uint8Array(voxels))`.
                *   Resolves the corresponding Promise in `pendingChunkRequests`.
            *   Added `public handleChunkResponseError(cx, cz, reason)`:
                *   Called by `NetworkManager` for `chunkResponseError` messages.
                *   Rejects the corresponding Promise.
        *   **`NetworkManager.ts` Modifications:**
            *   Constructor updated to pass an `onOpenCallback` to `WebSocketClient`.
            *   This `onOpenCallback` is: `(socket) => { if (this.chunkManager) { this.chunkManager.setSocket(socket); } }`.
            *   The main `wsClient.onMessage` handler in `NetworkManager` now checks for message types `chunkResponse` and `chunkResponseError`. If detected, it calls `this.chunkManager.handleChunkResponse(...)` or `this.chunkManager.handleChunkResponseError(...)` respectively.
        *   **`WebSocketClient.ts` Modifications:**
            *   Constructor now accepts an optional `onOpenCallback: (socket: WebSocket) => void`.
            *   In its internal `this.ws.onopen` handler, if this callback is provided, it's called with the active `WebSocket` instance.
    *   **Verification:**
        *   Server logs confirm receipt of `chunkRequest` from client, generation/caching by `getOrCreateChunk`, and sending of `chunkResponse`.
        *   Client logs confirm sending of `chunkRequest`, receipt and processing of `chunkResponse` from server, and subsequent loading/meshing of the chunk using server-provided data.
        *   Fallback to local generation on timeout/no-socket was also included in the `ChunkManager` logic.
        *   This makes chunk loading for viewing server-authoritative, fulfilling S1-3.

6. Development Learnings & LLM Guidance (New Section)

   This section captures broader learnings from the development process that may be useful for future AI assistants or human developers joining the project.

   *   **External Tooling & Environment:**
       *   Be prepared for challenges with external tools like compilers (`flatc`) or runtimes. Manual downloads, specific version requirements, and platform-specific binaries are sometimes necessary.
       *   Environment variable issues (e.g., `TS_NODE_COMPILER_OPTIONS`) can be subtle and may require simple but non-obvious fixes like restarting terminals or IDEs.
       *   Build tool configurations (e.g., `vitest.config.ts`) might need adjustments (`silent: false`, `exclude` paths) to aid debugging by making logs more visible or by correctly scoping test execution.

   *   **Library Integration & Debugging (e.g., FlatBuffers `BigInt` issue):**
       *   When integrating new libraries, especially for complex features like binary serialization, pay close attention to:
           *   **Version Compatibility:** Ensure the library version matches examples or known-good configurations. Mismatches (e.g., FlatBuffers runtime `^25.x` vs `^23.5.26`) can lead to silent failures or unexpected behavior.
           *   **Compiler/Generator Flags:** Critical features might depend on specific flags (e.g., `--gen-object-api` for FlatBuffers `BigInt` handling with the Object API).
           *   **Usage Patterns:** Adhere to recommended usage patterns from official documentation or reliable examples, especially if multiple APIs exist within the library (e.g., FlatBuffers VTable access vs. Object API).
       *   **"Triage Kit" Approach:** When facing persistent issues with a library, creating a minimal, isolated test case or "probe script" (like `scratch/fb_int64_probe.ts`) can be highly effective. This helps determine if the problem lies in the library itself, its configuration, or its interaction with the broader project.
       *   **Iterative Debugging:** Expect an iterative process. Use logging extensively, try different approaches, and consult documentation or community resources.

   *   **Client vs. Server Context:**
       *   The project involves distinct client-side (`src/`) and server-side (`src/server/`) codebases. Be mindful of which context is being discussed or modified.
       *   Features like ECS are being implemented on both client and server, but their components and systems might differ. For example, `src/ecs/components/` primarily contains client-side definitions, while server-side ECS components are co-located with the server's ECS world definition (e.g., `src/server/ecs/world.js`).

   *   **Project Evolution & Documentation:**
       *   This `project_overview_for_llm.txt` is a living document. As new features are added or issues resolved, updating this overview with key decisions, learnings, and current status is crucial for maintaining context for AI assistants and team members.
       *   Refer to commit history and user summaries for recent changes if the document seems out of sync.

   *   **Task Milestones:**
       *   Development is structured around milestones (e.g., S0-1, S1-1, S1-2, S1-3). Refer to these when discussing progress or planning next steps. 