// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Vec3, Vec3T } from '../game-schema/vec3.js';


export class PlayerInput implements flatbuffers.IUnpackableObject<PlayerInputT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PlayerInput {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPlayerInput(bb:flatbuffers.ByteBuffer, obj?:PlayerInput):PlayerInput {
  return (obj || new PlayerInput()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPlayerInput(bb:flatbuffers.ByteBuffer, obj?:PlayerInput):PlayerInput {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PlayerInput()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

seq():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
}

movementIntent(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Vec3()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

yaw():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
}

jumpPressed():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

flyDownPressed():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

isFlying():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startPlayerInput(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addSeq(builder:flatbuffers.Builder, seq:number) {
  builder.addFieldInt32(0, seq, 0);
}

static addMovementIntent(builder:flatbuffers.Builder, movementIntentOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, movementIntentOffset, 0);
}

static addYaw(builder:flatbuffers.Builder, yaw:number) {
  builder.addFieldFloat32(2, yaw, 0.0);
}

static addJumpPressed(builder:flatbuffers.Builder, jumpPressed:boolean) {
  builder.addFieldInt8(3, +jumpPressed, +false);
}

static addFlyDownPressed(builder:flatbuffers.Builder, flyDownPressed:boolean) {
  builder.addFieldInt8(4, +flyDownPressed, +false);
}

static addIsFlying(builder:flatbuffers.Builder, isFlying:boolean) {
  builder.addFieldInt8(5, +isFlying, +false);
}

static endPlayerInput(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishPlayerInputBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
}

static finishSizePrefixedPlayerInputBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
}


unpack(): PlayerInputT {
  return new PlayerInputT(
    this.seq(),
    (this.movementIntent() !== null ? this.movementIntent()!.unpack() : null),
    this.yaw(),
    this.jumpPressed(),
    this.flyDownPressed(),
    this.isFlying()
  );
}


unpackTo(_o: PlayerInputT): void {
  _o.seq = this.seq();
  _o.movementIntent = (this.movementIntent() !== null ? this.movementIntent()!.unpack() : null);
  _o.yaw = this.yaw();
  _o.jumpPressed = this.jumpPressed();
  _o.flyDownPressed = this.flyDownPressed();
  _o.isFlying = this.isFlying();
}
}

export class PlayerInputT implements flatbuffers.IGeneratedObject {
constructor(
  public seq: number = 0,
  public movementIntent: Vec3T|null = null,
  public yaw: number = 0.0,
  public jumpPressed: boolean = false,
  public flyDownPressed: boolean = false,
  public isFlying: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const movementIntent = (this.movementIntent !== null ? this.movementIntent!.pack(builder) : 0);

  PlayerInput.startPlayerInput(builder);
  PlayerInput.addSeq(builder, this.seq);
  PlayerInput.addMovementIntent(builder, movementIntent);
  PlayerInput.addYaw(builder, this.yaw);
  PlayerInput.addJumpPressed(builder, this.jumpPressed);
  PlayerInput.addFlyDownPressed(builder, this.flyDownPressed);
  PlayerInput.addIsFlying(builder, this.isFlying);

  return PlayerInput.endPlayerInput(builder);
}
}
